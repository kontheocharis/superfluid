{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE FlexibleContexts #-}

module Compiler (runCli) where

-- import Checking.Context (Tc, TcState)
-- import Checking.Normalisation (normaliseTermFully, normaliseProgram)
-- import Checking.Representation (representProgram)
-- import Checking.Typechecking (checkProgram, inferTerm)
-- import Checking.Utils (runTc)

-- import Interface.Pretty

-- import Codegen.Generate (Gen, runGen, generateProgram, JsProg, renderJsProg)

import Common (HasNameSupply (..), HasProjectFiles (getProjectFileContents), Name (..))
import Control.Monad (void, when)
import Control.Monad.Except (ExceptT, MonadError (..), runExceptT)
import Control.Monad.IO.Class (MonadIO, liftIO)
import Control.Monad.State (MonadState (get, put), StateT (..))
import Control.Monad.State.Class (gets, modify)
import Data.Map (Map)
import qualified Data.Map as M
import Data.String
import Data.Text.IO (hPutStrLn)
import Elaboration (Ctx, Elab (..), ElabError, emptyCtx, checkProgram)
import Evaluation (Eval (..))
import Globals (HasSig (..), Sig, emptySig)
import Meta (HasMetas (..), SolvedMetas, emptySolvedMetas)
import Options.Applicative (execParser, (<**>), (<|>))
import Options.Applicative.Builder (fullDesc, header, help, info, long, progDesc, short, strOption, switch)
import Options.Applicative.Common (Parser)
import Options.Applicative.Extra (helper)
import Parsing (parseProgram)
import Presyntax (PProgram)
import Printing (Pretty (..))
import System.Console.Haskeline (InputT, defaultSettings, runInputT)
import System.Exit (exitFailure)
import System.IO (stderr)
import Unification (Unify)
import Persistence (preludePath)

-- import Resources.Prelude (preludePath, preludeContents)

-- | What mode to run in.
data Mode
  = -- | Typecheck a file.
    CheckFile String
  | -- | Parse a file
    ParseFile String
  | -- | Represent a file
    RepresentFile String
  | -- | Generate code
    GenerateCode String
  deriving (Show)

-- | Command-line flags.
data Flags = Flags
  { -- | Whether to dump the program.
    dump :: Bool,
    -- | Whether to be verbose.
    verbose :: Bool,
    -- | Normalise the program in the end.
    normalise :: Bool
  }
  deriving (Show)

-- | Command-line arguments.
data Args = Args
  { argsMode :: Mode,
    argsFlags :: Flags
  }
  deriving (Show)

-- | Parse the command-line flags.
parseFlags :: Parser Flags
parseFlags =
  Flags
    <$> switch (long "dump" <> short 'd' <> help "Print the parsed program")
    <*> switch (long "verbose" <> short 'v' <> help "Be verbose")
    <*> switch (long "normalise" <> short 'n' <> help "Normalise the program")

-- | Parse the mode to run in.
parseMode :: Parser Mode
parseMode =
  (CheckFile <$> strOption (long "check" <> short 'c' <> help "File to check"))
    <|> (ParseFile <$> strOption (long "parse" <> short 'p' <> help "File to parse"))
    <|> (RepresentFile <$> strOption (long "represent" <> short 'r' <> help "File to represent"))
    <|> (GenerateCode <$> strOption (long "generate" <> short 'g' <> help "File to generate code for"))

-- | Parse the command line arguments.
parseArgs :: Parser Args
parseArgs = Args <$> parseMode <*> parseFlags

-- | Run the main CLI.
runCli :: IO ()
runCli = do
  args <- execParser opts
  runComp (compile args) emptyCompiler
  where
    opts =
      info
        (parseArgs <**> helper)
        ( fullDesc
            <> progDesc "Superfluid is a dependently typed programming language with customisable type representations"
            <> header "Superfluid"
        )

-- | Log a message.
msg :: String -> Comp ()
msg m = do
  liftIO $ putStrLn m
  return ()

-- | Log a message to stderr and exit with an error code.
err :: String -> Comp a
err m = liftIO $ do
  hPutStrLn stderr $ fromString m
  exitFailure

data Compiler = Compiler
  { files :: Map String String,
    solvedMetas :: SolvedMetas,
    ctx :: Ctx,
    sig :: Sig,
    inPat :: Bool,
    reduceUnderBinders :: Bool,
    lastNameIdx :: Int,
    reduceUnfoldDefs :: Bool
  }

data CompilerError = ElabCompilerError ElabError | ParseCompilerError String

instance Pretty Comp CompilerError where
  pretty (ElabCompilerError e) = pretty e
  pretty (ParseCompilerError e) = return e

newtype Comp a = Comp {unComp :: ExceptT CompilerError (StateT Compiler IO) a}
  deriving (Functor, Applicative, Monad, MonadState Compiler, MonadError CompilerError, MonadIO)

instance HasMetas Comp where
  solvedMetas = gets (\c -> c.solvedMetas)
  modifySolvedMetas f = modify (\s -> s {solvedMetas = f s.solvedMetas})

instance HasSig Comp where
  getSig = gets (\c -> c.sig)
  modifySig f = modify (\s -> s {sig = f s.sig})

instance HasNameSupply Comp where
  uniqueName = do
    n <- gets (\c -> c.lastNameIdx)
    modify (\s -> s {lastNameIdx = n + 1})
    return . Name $ "x" ++ show n

instance Eval Comp where
  reduceUnderBinders = gets (\c -> c.reduceUnderBinders)
  setReduceUnderBinders b = modify (\s -> s {reduceUnderBinders = b})
  reduceUnfoldDefs = gets (\c -> c.reduceUnfoldDefs)
  setReduceUnfoldDefs b = modify (\s -> s {reduceUnfoldDefs = b})

instance Unify Comp

instance Elab Comp where
  getCtx = gets (\c -> c.ctx)
  setCtx ctx = modify (\s -> s {ctx = ctx})
  elabError e = throwError $ ElabCompilerError e

instance HasProjectFiles Comp where
  getProjectFileContents f = do
    fs <- gets (\c -> c.files)
    return $ M.lookup f fs

emptyCompiler :: Compiler
emptyCompiler =
  Compiler
    { files = M.empty,
      solvedMetas = emptySolvedMetas,
      ctx = emptyCtx,
      sig = emptySig,
      inPat = False,
      reduceUnderBinders = False,
      lastNameIdx = 0,
      reduceUnfoldDefs = False
    }

runComp :: Comp a -> Compiler -> IO ()
runComp c s = do
  let c' = do
        void c
          `catchError` ( \e -> do
                           e' <- pretty e
                           err e'
                       )
  (_, _) <- runStateT (runExceptT c'.unComp) s
  return ()

-- | Run the compiler.
compile :: Args -> Comp ()
compile args = do
  case args of
    Args (CheckFile file) flags -> do
      parseAndCheckPrelude
      parsed <- parseFile file
      checkProgram parsed
      when flags.verbose $ msg "\nTypechecked program successfully"
    -- when flags.dump $ msg $ printVal checked
    Args (ParseFile file) flags -> do
      parsed <- parseFile file
      when flags.verbose $ msg $ "Parsing file " ++ file
      printed <- pretty parsed
      when flags.dump . msg $ printed
    Args (RepresentFile file) flags -> error "unimplemented"
      -- represented <- andPotentiallyNormalise flags <$> representFile file
      -- when flags.verbose $ msg "\nTypechecked and represented program successfully"
    -- when flags.dump $ msg $ printVal represented
    Args (GenerateCode file) flags -> error "unimplemented"
      -- code <- generateCode file
      -- when flags.verbose $ msg "Generated code successfully"

-- when flags.dump $ msg $ renderJsProg code

parseAndCheckPrelude :: Comp ()
parseAndCheckPrelude = do
  parsed <- parseFile preludePath
  checkProgram parsed

-- | Parse a file with the given name and add it to the program
parseFile :: String -> Comp PProgram
parseFile file = do
  contents <- liftIO $ readFile file
  modify (\c -> c {files = M.insert file contents c.files})
  case parseProgram file contents of
    Left e -> throwError $ ParseCompilerError e
    Right p -> return p

-- -- | Parse, check and represent a file.
-- representFile :: String -> InputT IO Program
-- representFile file = do
--   (parsed, _, st) <- parseFile' file
--   (checked, st') <- handleTc err (put st >> checkProgram parsed)
--   (represented, _) <- handleTc err (put st' >> representProgram checked)
--   return represented

-- -- | Parse, check and represent a file.
-- -- generateCode :: String -> InputT IO JsProg
-- -- generateCode file = do
-- --   (parsed, prelude, st) <- parseFile' file
-- --   (checked, st') <- handleTc err (put st >> checkProgram parsed)
-- --   (represented, _) <- handleTc err (put st' >> normaliseProgram <$> representProgram (prelude <> checked))
-- --   generated <- handleGen err (generateProgram represented)
-- --   emitFile (file ++ ".js") (renderJsProg generated)
-- --   return generated

-- -- | Emit a file.
-- emitFile :: String -> String -> InputT IO ()
-- emitFile file contents = do
--   liftIO $ writeFile file contents
--   msg $ "Wrote file " ++ file

-- -- | Handle a parsing result.
-- handleParse :: (String -> Comp a) -> Either String a -> Comp a
-- handleParse er res = do
--   case res of
--     Left e -> er $ "Failed to parse: " ++ e
--     Right p -> return p

-- -- | Handle a checking result.
-- handleTc :: (String -> InputT IO (a, Ctx)) -> Comp a -> InputT IO (a, Ctx)
-- handleTc er a = do
--   case runTc a of
--     Left e -> do
--       er $ "Typechecking error: " ++ show e
--     Right (p, s) -> return (p, s)

-- -- | Handle a generation result.
-- -- handleGen :: (String -> InputT IO a) -> Gen a -> InputT IO a
-- -- handleGen er a = do
-- --   case runGen a of
-- --     Left e -> do
-- --       er $ "Code generation error: " ++ show e
-- --     Right p -> return p
