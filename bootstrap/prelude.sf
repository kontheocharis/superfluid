-- General types

data Unit : Type {
  tt : Unit
}

data Bool : Type {
  true : Bool,
  false : Bool
}

data Sigma (A : Type, B : A -> Type) : Type {
  pair : (a : A) -> B a -> Sigma A B
}

data Equal [A : Type] : A -> A -> Type {
  refl : [x : A] -> Equal x x
}

def dup : [A : Type] -> A -> A * A {
  \a => (a, a)
}

def fst : [A : Type, B : A -> Type] -> Sigma A B -> A {
  \p => case p {
    (a, b) => a
  }
}

def snd : [A : Type, B : A -> Type] -> (p : Sigma A B) -> B (fst p) {
  \[_] [B] p => case p to (\p => B (fst p)) {
    (a, b) => b
  }
}

#unfold
def id : [A : Type] -> A -> A {
  \a => a
}

def if-then-else : [A : Type] -> Bool -> (Unit -> A) -> (Unit -> A) -> A {
  \[A] b t f => case b {
    true => t tt,
    false => f tt
  }
}

prim trust-me : [A : Type, x : A, y : A] -> Equal x y

prim conjure : (A : Type) -> A

-- -- JS primitives

prim JsUnion : Type -> Type -> Type

prim JsNull : Type

prim JsUndefined : Type

prim JsBool : Type

prim JsArray : Type -> Type

prim JsBigInt : Type

prim JsUint : Type

-- Extra conditions : make sure this index is computationally irrelevant

prim JsBoundedUint : JsUint -> Type

prim JsNumber : Type

prim JsString : Type

prim js-null : JsNull

prim js-undefined : JsUndefined

prim js-true : JsBool

prim js-false : JsBool

prim js-if : [A : Type] -> JsBool -> (() -> A) -> (() -> A) -> A

prim js-if-dep : [A : JsBool -> Type] -> (b : JsBool) -> (() -> A js-true) -> (() -> A js-false) -> A b

prim js-empty-array : [T : Type] -> JsArray T

prim js-array-extend-l : [T : Type] -> T -> JsArray T -> JsArray T

prim js-array-extend-r : [T : Type] -> JsArray T -> T -> JsArray T

prim js-array-switch-l : [T : Type] -> [E : JsArray T -> Type]
  -> (Unit -> E js-empty-array)
  -> ((x : T) -> (xs : JsArray T) -> E (js-array-extend-l x xs))
  -> (l : JsArray T)
  -> E l

prim js-array-switch-r : [T : Type] -> [E : JsArray T -> Type]
  -> (Unit -> E js-empty-array)
  -> ((xs : JsArray T) -> (x : T) -> E (js-array-extend-r xs x))
  -> (l : JsArray T)
  -> E l

prim js-slice : [T : Type] -> JsArray T -> JsNumber -> JsNumber -> JsArray T

prim js-length : [T : Type] -> JsArray T -> JsUint

prim js-map : [A B : Type] -> (a : JsArray A) -> ((A * JsBoundedUint (js-length a)) -> B) -> JsArray B

prim js-reduce : [T C : Type] -> (C -> T -> C) -> C -> JsArray T -> C

prim js-index : [T : Type] -> (a : JsArray T) -> JsBoundedUint (js-length a) -> T

prim js-if-bounded : [A : Type] -> JsUint -> (n : JsUint) -> (JsBoundedUint n -> A) -> (() -> A) -> A

prim js-assert-defined : [T : Type] -> JsUnion T JsUndefined -> T

prim js-zero : JsNumber

prim js-one : JsNumber

prim js-uint-zero : JsUint

prim js-uint-one : JsUint

prim js-plus : JsNumber -> JsNumber -> JsNumber

prim js-uint-plus : JsUint -> JsUint -> JsUint

prim js-forget-bound : [n : JsUint] -> JsBoundedUint n -> JsUint

prim js-zero-or-pos : [A : JsUint -> Type]
  -> (() -> A js-uint-zero)
  -> ((n : JsUint) -> A (js-uint-plus js-uint-one n))
  -> (i : JsUint)
  -> A i

prim js-bounded-uint-zero : [n : JsUint] -> JsBoundedUint (js-uint-plus js-uint-one n)

prim js-bounded-uint-inc : [n : JsUint] -> JsBoundedUint n -> JsBoundedUint (js-uint-plus js-uint-one n)

prim js-bounded-zero-or-pos : [A : (n : JsUint) -> JsBoundedUint n -> Type]
  -> ([n : JsUint] -> A (js-uint-plus js-uint-one n) (js-bounded-uint-zero [n]))
  -> ([n : JsUint] -> (n' : JsBoundedUint n) -> A (js-uint-plus js-uint-one n) (js-bounded-uint-inc n'))
  -> [n : JsUint]
  -> (i : JsBoundedUint n)
  -> A n i

prim js-minus : JsNumber -> JsNumber -> JsNumber

prim js-times : JsNumber -> JsNumber -> JsNumber

prim js-uint-times : JsUint -> JsUint -> JsUint

prim js-div : JsNumber -> JsNumber -> JsNumber

prim js-mod : JsNumber -> JsNumber -> JsNumber

prim js-uint-mod : JsUint -> JsUint -> JsUint

prim js-pow : JsNumber -> JsNumber -> JsNumber

prim js-uint-pow : JsUint -> JsUint -> JsUint

prim js-neg : JsNumber -> JsNumber

prim js-eq : [A B : Type] -> A -> B -> JsBool

prim js-eqq : [A B : Type] -> A -> B -> JsBool

prim js-neq : [A B : Type] -> A -> B -> JsBool

prim js-neqq : [A B : Type] -> A -> B -> JsBool

prim js-lt : JsNumber -> JsNumber -> JsBool

prim js-lte : JsNumber -> JsNumber -> JsBool

prim js-gt : JsNumber -> JsNumber -> JsBool

prim js-gte : JsNumber -> JsNumber -> JsBool

prim js-and : JsBool -> JsBool -> JsBool

prim js-or : JsBool -> JsBool -> JsBool

prim js-not : JsBool -> JsBool

prim js-panic : [T : Type] -> JsString -> T

-- -- IO

prim IO : Type -> Type

prim io-return : [A : Type] -> A -> IO A

prim io-bind : [A : Type] -> [B : Type] -> IO A -> (A -> IO B) -> IO B

prim unsafe-io : [A : Type] -> IO A -> A

-- -- JS IO

prim js-console-log : [T : Type] -> T -> IO ()

prim js-prompt : IO JsString

-- -- JS Buffer

prim JsBuffer : Type

prim JsBufferMod : Type -> Type

prim js-buffer-bind : [A B : Type] -> JsBufferMod A -> (A -> JsBufferMod B) -> JsBufferMod B

prim js-buffer-return : [A : Type] -> A -> JsBufferMod A

prim js-buffer-get : JsBufferMod JsBuffer

prim js-buffer-set : JsBuffer -> JsBufferMod ()

prim js-buffer-empty : JsBuffer

prim js-buffer-run : [A : Type] -> JsBuffer -> JsBufferMod A -> JsBuffer * A

prim js-buffer-alloc : (byte-length : JsUint) -> JsBuffer

prim js-buffer-byte-length : JsBuffer -> JsUint

prim js-buffer-copy : (source : JsBuffer, source-start : JsUint, source-end : JsUint, start : JsUint) -> JsBufferMod ()

prim js-buffer-write-uint16-be : (value : JsUint, offset : JsUint) -> JsBufferMod ()

prim js-buffer-write-uint8 : (value : JsUint, offset : JsUint) -> JsBufferMod ()

prim js-buffer-read-uint16-be : (buffer : JsBuffer, offset : JsUint) -> JsUint

prim js-buffer-read-uint8 : (buffer : JsBuffer, offset : JsUint) -> JsUint

prim js-buffer-subarray : (buffer : JsBuffer, start : JsUint, end : JsUint) -> JsBuffer

prim js-bound-trust-me : [n : JsUint] -> JsUint -> JsBoundedUint n

-- -- General primitives

prim unsafe-cast : [A : Type] -> (B : Type) -> A -> B

prim unsafe-complete : [T : Type] -> (E : T -> Type) -> (t : T) -> [u : T] -> (h : E u) -> E t

-- def from-js : [A : Type] -> JS -> A {
--   \a => cast a
-- }

def debug-print : [A B : Type] -> A -> B -> B {
  \a b => unsafe-io (io-bind (js-console-log a) (\_ => io-return b))
}

data Maybe (A : Type) : Type {
  nothing : Maybe A,
  just : A -> Maybe A
}

data Either (L : Type) (R : Type) : Type {
  left : L -> Either L R,
  right : R -> Either L R
}

data Nat : Type {
  z : Nat,
  s : Nat -> Nat
}

data List (A : Type) : Type {
  nil : List A,
  cons : A -> List A -> List A
}

data Fin : Nat -> Type {
  fz : [n : Nat] -> Fin (s n),
  fs : [n : Nat] -> Fin n -> Fin (s n)
}

data Empty : Type {}

def void : [A : Type] -> Empty -> A {
  \m => case m {}
}

data Dec (A : Type) : Type {
  yes : A -> Dec A,
  no : (A -> Empty) -> Dec A
}

def add : Nat -> Nat -> Nat {
  \m n => case m {
    z => n,
    s m' => s (add m' n),
  }
}

def sub : Nat -> Nat -> Nat {
  \m n => case n {
    z => m,
    s n' => case m {
      z => z,
      s m' => sub m' n',
    }
  }
}

def mul : Nat -> Nat -> Nat {
  \m n => case m {
    z => z,
    s m' => add n (mul m' n),
  }
}

def is-even : Nat -> Bool {
  \n => case n {
    z => true,
    s n' => case n' {
      z => false,
      s n'' => is-even n'',
    }
  }
}

def pow : Nat -> Nat -> Nat {
  \m n => case n {
    z => s z,
    s n' => mul m (pow m n'),
  }
}

def and : Bool -> Bool -> Bool {
  \a b => case a {
    true => b,
    false => false,
  }
}

def or : Bool -> Bool -> Bool {
  \a b => case a {
    true => true,
    false => b,
  }
}

def not : Bool -> Bool {
  \a => case a {
    true => false,
    false => true,
  }
}

def fin-to-nat : [n : Nat] -> Fin n -> Nat {
  \f => case f {
    fz => z,
    fs f' => s (fin-to-nat f'),
  }
}

def fin-is-even : [n : Nat] -> Fin n -> Bool {
  \x => case x {
    fz => true,
    fs x => case x {
      fz => false,
      fs y => fin-is-even y
    }
  }
}

def upgrade : [n : Nat] -> (k : Nat) -> Fin n -> Fin (add k n) {
  \[n] k => case k to (\m => Fin n -> Fin (add m n)) {
    z => id,
    s k' => \x => fs (upgrade k' x)
  }
}

def fin-eq : [n : Nat] -> [m : Nat] -> Fin n -> Fin m -> Bool {
  \a b => case a {
    fz => case b {
      fz => true,
      fs y => false
    },
    fs x => case b {
      fz => false,
      fs y => fin-eq x y
    }
  }
}

def length : [A : Type] -> List A -> Nat {
  \xs => case xs {
    nil => z,
    cons _ xs' => s (length xs'),
  }
}

def type : [A : Type] -> A -> Type {
  \[A] _ => A
}

def map : [A : Type] -> [B : Type] -> (A -> B) -> List A -> List B {
  \f xs => case xs {
    nil => nil,
    cons x xs' => cons (f x) (map f xs')
  }
}

def find : [A : Type] -> (A -> Bool) -> List A -> Maybe A {
  \p xs => case xs {
    nil => nothing,
    cons x xs' => case p x {
      true => just x,
      false => find p xs'
    }
  }
}

def fold : [A : Type] -> [B : Type] -> (A -> B -> B) -> B -> List A -> B {
  \f acc xs => case xs {
    nil => acc,
    cons x xs' => f x (fold f acc xs')
  }
}

def index : [A : Type] -> Nat -> List A -> Maybe A {
  \n xs => case xs {
    nil => nothing,
    cons x xs' => case n {
      z => just x,
      s n' => index n' xs'
    }
  }
}

def subst : [A : Type, x : A, y : A] -> (P : A -> Type) -> Equal x y -> P x -> P y {
  \P e => case e to (\x y _ => P x -> P y) {
    refl => id
  }
}

def subst-type : [A B : Type] -> Equal A B -> A -> B {
  subst [Type] (\X => X)
}

def cong : [A : Type, B : Type, x : A, y : A] -> (f : A -> B) -> Equal x y -> Equal (f x) (f y) {
  \f e => case e to (\x y _ => Equal (f x) (f y)) {
    refl => refl
  }
}

def sym : [A : Type, x : A, y : A] -> Equal x y -> Equal y x {
  \e => case e to (\x y _ => Equal y x) {
    refl => refl
  }
}

def z-neq-s : [n : Nat] -> Equal z (s n) -> Empty {
  \p => subst [Nat] (\n => case n {
    z => Unit,
    s _ => Empty,
  }) p tt
}

def co-sym : [A : Type, x : A, y : A] -> (Equal x y -> Empty) -> (Equal y x -> Empty) {
  \m p => m (sym p)
}

def s-inj : [n : Nat, m : Nat] -> Equal (s n) (s m) -> Equal n m {
  \e => subst [Nat] (\x => Equal n (case x {
    z => n,
    s k => k
  })) e refl
}

def s-co-cong : [x : Nat, y : Nat] -> (Equal x y -> Empty) -> (Equal (s x) (s y) -> Empty) {
  \m p => m (s-inj p)
}

def nat-eq-dep : (n : Nat, m : Nat) -> Dec (Equal n m) {
  \n m => case n to (\n => Dec (Equal n m)) {
    z => case m to (\m => Dec (Equal z m)) {
      z => yes refl,
      s m' => no z-neq-s,
    },
    s n' => case m to (\m => Dec (Equal (s n') m)) {
      z => no (co-sym z-neq-s),
      s m' => case nat-eq-dep n' m' to (\e => Dec (Equal (s n') (s m'))) {
        yes e => yes (cong s e),
        no f => no (s-co-cong f)
      }
    }
  }
}

def dec-to-bool : [A : Type] -> Dec A -> Bool {
  \case {
    yes _ => true,
    no _ => false
  }
}

def nat-eq : (n : Nat, m : Nat) -> Bool {
  \n m => dec-to-bool (nat-eq-dep n m)
}

def lte : Nat -> Nat -> Bool {
  \m n => case m {
    z => true,
    s m' => case n {
      z => false,
      s n' => lte m' n',
    }
  }
}

def lt : Nat -> Nat -> Bool {
  \m n => and (not (nat-eq m n)) (lte m n)
}

def bool-eq : (a : Bool, b : Bool) -> Bool {
  \a b => case a {
    true => case b {
      true => true,
      false => false,
    },
    false => case b {
      true => false,
      false => true,
    }
  }
}

def mod : Nat -> Nat -> Nat {
  \a n => case n {
    z => a,
    s k => case lt a n {
      true => a,
      false => mod (sub a (s k)) (s k)
    },
  }
}

-- -- Default representations
repr data Bool as JsBool {
  true as js-true,
  false as js-false,

  case b to E {
    true => t,
    false => f,
  } as {
    js-if-dep [repr E] (repr b) (\_ => repr t) (\_ => repr f)
  }
}

repr def and as \a b => unrepr (js-and (repr a) (repr b))
repr def or as \a b => unrepr (js-or (repr a) (repr b))
repr def not as \a => unrepr (js-not (repr a))

repr data Nat as JsUint {
  z as js-uint-zero,
  s n as js-uint-plus js-uint-one (repr n),
  case n to E {
    z => b,
    s => r,
  } as {
    js-zero-or-pos [repr E] (\_ => repr b) (repr r) (repr n)
  }
}

repr def add as \a b => unrepr (js-uint-plus (repr a) (repr b))
repr def mul as \a b => unrepr (js-uint-times (repr a) (repr b))
repr def pow as \a b => unrepr (js-uint-pow (repr a) (repr b))
repr def is-even as \n => unrepr (js-eqq (js-uint-mod (repr n) (repr 1)) js-uint-zero)
repr def mod as \a b => unrepr (js-uint-mod (repr a) (repr b))
repr def nat-eq as \a b => unrepr (js-eqq (repr a) (repr b))

repr data Fin i as JsBoundedUint (repr i) {
  fz as js-bounded-uint-zero,
  fs n as js-bounded-uint-inc (repr n),
  case n to E {
    fz => b,
    fs => r,
  } as {
    js-bounded-zero-or-pos [repr E] (repr b) (repr r) (repr n)
  }
}

repr def fin-to-nat as \n => {
  unrepr (js-forget-bound (repr n))
}

repr def fin-is-even as \n => {
  unrepr (js-eqq (js-uint-mod (js-forget-bound (repr n)) (repr 2)) js-uint-zero)
}

repr def fin-eq as \x y => unrepr (js-eqq (repr x) (repr y))

repr data List A as JsArray A {
  nil as js-empty-array,
  cons x xs as js-array-extend-l x (repr xs),

  case l to E {
    nil => n,
    cons => c,
  } as {
    js-array-switch-l [A] [repr E] (\_ => repr n) (\a xs => repr (c a (unrepr xs))) (repr l)
  }
}

repr def length as \l => unrepr (js-length (repr l))

repr def index as {
  \i l => {
    let l' = repr l;
    js-if-bounded (repr i) (js-length l')
      (\b => just (js-index l' b))
      (\_ => nothing)
  }
}

repr def map as \f xs => unrepr (js-map (repr xs) (\case { (a, _) => f a }))

repr def fold as \f i xs => js-reduce (\acc x => f x acc) i (repr xs)

-- This is wildly inconsistent, make it a JS primitive!
repr data Equal [A] x y as JsUndefined {
  refl as js-undefined,
  case e to E {
    refl => r,
  } as {
    unsafe-cast ((repr E) _ _ (repr e)) (repr (r [conjure A]))
  }
}

-- -- -- More definitions

data Char : Type {
  char-from-num : Fin 32 -> Char,
}

data String : Type {
  snil : String,
  scons : Char -> String -> String,
}

def Word : Type {
  Fin 65536
}

def Byte : Type {
  Fin 256
}

def word-to-nat : Word -> Nat {
  fin-to-nat
}

def Holds : Bool -> Type {
  \b => Equal b true
}


-- Byte lists and vectors

data ByteList : Type {
  bnil : ByteList,
  bcons : Byte -> ByteList -> ByteList
}

def byte-list-length : ByteList -> Nat {
  \l => case l {
    bnil => z,
    bcons _ xs => s (byte-list-length xs)
  }
}

data ByteVec : Nat -> Type {
  bvnil : ByteVec z,
  bvcons : [n : Nat] -> Byte -> ByteVec n -> ByteVec (s n)
}

def byte-vec-length : [n : Nat] -> ByteVec n -> Nat {
  \[n] b => n
}

repr data ByteList as JsBuffer {
  bnil as js-buffer-empty,
  bcons x xs as {
    let old = repr xs;
    let old-len = js-buffer-byte-length old;
    let new-len = js-uint-plus old-len (repr 1);
    let b = js-buffer-run (js-buffer-alloc new-len) ({
      js-buffer-bind
        (js-buffer-copy old (repr 0) old-len (repr 1))
        (\_ => js-buffer-write-uint8 (js-forget-bound (repr x)) (repr 0))
    });
    fst b
  },

  case b to E {
    bnil => n,
    bcons => c
  } as {
    let b' = repr b;
    js-if (js-eqq (js-buffer-byte-length b') (repr 0))
      (\_ => unsafe-complete (repr E) b' (repr n))
      (\_ => {
        let x : Byte = unrepr (js-bound-trust-me [repr 256] (js-buffer-read-uint8 b' (repr 0)));
        let xs : ByteList = unrepr (js-buffer-subarray b' (repr 1) (js-buffer-byte-length b'));
        let m = repr (c x xs);
        unsafe-complete (repr E) b' m
      })
  }
}

-- The `n` can be computed from the data structure!!
repr data ByteVec n as (l : ByteList) * Equal (byte-list-length l) n {
  bvnil as (bnil, refl),
  bvcons x xs as case (repr xs) {
    (l, p) => (bcons x l, cong s p)
  },

  case b to E {
    bvnil => n,
    bvcons => c
  } as {
    let b' = repr b;
    let res = case b' to (\p => (repr (E (byte-list-length (fst p)))) (fst p, refl)) {
      (l, p) => case l to (\l => repr (E (byte-list-length l)) (l, refl)) {
        bnil => repr n,
        bcons x xs => repr (c [byte-list-length xs] x (unrepr (xs, refl))),
      }
    };
    -- let length-pres : Equal (byte-list-length (fst b')) (byte-vec-length b) = trust-me; -- we can probably prove this
    -- @@Todo: do this without cast and trust me
    unsafe-cast (repr (E (byte-vec-length b) b)) res
  }
}


-- REPR helpers

def Reprs : Nat -> Type -> Type {
  \l T => case l {
    z => T,
    s l' => repr (Reprs l' T)
  }
}

def reprs : [T : Type] -> (l : Nat) -> T -> Reprs l T {
  \l t => case l to (\l => Reprs l T) {
    z => t,
    s l' => repr (reprs l' t)
  }
}

def unreprs : [T : Type] -> (l : Nat) -> Reprs l T -> T {
  \l => case l to (\l => Reprs l T -> T) {
    z => id,
    s l' => \r => unreprs l' (unrepr r)
  }
}

def repr-subst : [A B : Type] -> Equal (repr A) B -> repr A -> B {
  subst-type
}

def repr-subst' : [A B : Type] -> Equal (repr A) B -> B -> repr A {
  \p => subst-type (sym p)
}

def ReprBy : Type -> Type -> Type {
  \T U => (l : Nat) * Equal (Reprs l T) U
}

def reprs-subst : [A B : Type] -> ReprBy A B -> A -> B {
  \r a => case r {
    (l, p) => subst-type p (reprs l a)
  }
}

def reprs-subst' : [A B : Type] -> ReprBy A B -> B -> A {
  \r b => case r {
    (l, p) => unreprs l (subst-type (sym p) b)
  }
}
