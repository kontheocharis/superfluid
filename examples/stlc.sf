data Bool : Type {
  true : Bool,
  false : Bool
}

data Ty : Type {
  alpha : Ty,
  fn : Ty -> Ty -> Ty
}

data Con : Type {
  empty : Con,
  extend : Con -> Ty -> Con
}

data Var : Con -> Ty -> Type {
  here : [c : Con] -> [t : Ty] -> Var (extend c t) t,
  there : [c : Con] -> [t : Ty] -> [t' : Ty] -> Var c t -> Var (extend c t') t
}

def var-eq : [c : Con] -> [t : Ty] -> Var c t -> Var c t -> Bool {
  \a b => case a {
    here => case b {
      here => true,
      there _ => false
    },
    there a' => case b {
      here => false,
      there b' => ?h34
    }
  }
}

def without : [t : Ty] -> (c : Con) -> Var c t -> Con {
  \c v => case v {
    here [c'] => c',
    there [c'] [_] [t'] v' => extend (without c' v') t'
  }
}

data Tm : Con -> Ty -> Type {
  var : [c : Con] -> [t : Ty] -> Var c t -> Tm c t,
  lam : [c : Con] -> [t1 : Ty] -> [t2 : Ty] -> Tm (extend c t1) t2 -> Tm c (fn t1 t2),
  app : [c : Con] -> [t1 : Ty] -> [t2 : Ty] -> Tm c (fn t1 t2) -> Tm c t1 -> Tm c t2
}

def subst : [t : Ty] -> [t' : Ty] -> [c : Con] -> (v : Var c t') -> Tm c t' -> Tm c t -> Tm (without c v) t {
  \v tm' tm => case tm { }
}

def id : [c : Con] -> Tm c (fn alpha alpha) {
  lam (var here)
}

