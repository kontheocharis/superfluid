def two : Nat {
  s (s z)
}

def two_to_the_sixteen : Nat {
  pow two (pow two (pow two two))
}

def field-len : Nat {
  two_to_the_sixteen
}

def byte-len : Nat {
  two_to_the_sixteen
}

data FinVec : [n : Nat] -> Type -> Fin n -> Type {
  fnil : [A: Type] -> [n : Nat] -> FinVec A (fz [n]),
  fcons : [A: Type] -> [n : Nat] -> [i : Fin n] -> A -> FinVec A i -> FinVec A (fs i)
}

data UdpPacket : Type {
  mk-udp-packet :
    (src-port : Fin field-len) ->
    (dst-port : Fin field-len) ->
    (len : Fin field-len) ->
    (checksum : Fin field-len) ->
    (contents : FinVec (Fin byte-len) len) ->
    UdpPacket
}

data Status : Type {
  ok : Status,
  error : Status
}

def process-udp-packet : UdpPacket -> Status {
  \p => case p {
    mk-udp-packet src-port dst-port len checksum contents => {
      -- Ensure the first byte is 0x00
      let first-byte : Maybe (Fin byte-len) = case contents {
        fcons i is => just i,
        fnil => nothing,
      };

      case first-byte {
        just x => case x {
          fz => ok,
          fs _ => error
        },
        nothing => error
      }
    }
  }
}

repr FinVecRepr {
  data FinVec A n as JS {
    fnil as js-empty-array,
    fcons x xs as js-array-extend-l (to-js x) xs,
    case l {
      fnil => n,
      fcons => c
    } as {
      js-if (js-eqq (js-length l) js-zero)
        (cast n)
        (cast (c [JS] [_] [_] (js-index l js-zero) (js-slice l js-one (js-length l))))
    }
  }
}

-- repr UdpRepr {
--   data UdpPacket as ByteArray {
--     mk-udp-packet src-port dst-port len checksum contents as {
--       (write-flat-array contents write-u
--       (write-u checksum
--       (write-u len
--       (write-u dst-port
--       (write-u src-port empty-byte-array)))))
--     },
--     case p {
--       mk-udp-packet => mk,
--     } as {
--       ?h2
--     }
--   }
-- }
