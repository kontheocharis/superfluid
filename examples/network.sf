def Word : Type {
  Fin 65536
}

def Byte : Type {
  Fin 256
}

data ByteVec : (n : Nat) -> Type {
  bnil : ByteVec z,
  bcons : [n : Nat] -> Byte -> ByteVec n -> ByteVec (s n)
}

data UdpPacket : Type {
  mk-udp-packet :
    (src-port : Word) ->
    (dst-port : Word) ->
    (len : Word) ->
    (checksum : Word) ->
    (contents : ByteVec (fin-to-nat len)) ->
    UdpPacket
}

def handle-packet : Nat -> UdpPacket -> Maybe UdpPacket {
  \seq p => case p {
    mk-udp-packet src-port dst-port len checksum contents => {
      -- The rule is, if the source port is even, forward the packet
      -- to the destination port, setting the source port to be our own.
      -- Otherwise, drop it.
      let own-port : Word = case is-even seq {
        true => 42n,
        false => 24n,
      };

      let new-p = mk-udp-packet own-port dst-port len checksum contents;
      just new-p
    }
  }
}

def rec repeat : (n : Nat) -> Byte -> ByteVec n {
  \n b => case n {
    z => bnil,
    s n' => bcons b (repeat n' b)
  }
}

def rec io-mapM_ : [A : Type] -> (A -> IO Unit) -> List A -> IO Unit {
  \f xs => case xs {
    nil => io-return tt,
    cons x xs' => {
      let m = io-bind (f x) (\_ => io-mapM_ f xs'); -- @@FIXME dies without this let??
      m
    }
  }
}

def rec count-to : Nat -> List Nat {
  \n => case n {
    z => nil,
    s n' => cons n' (count-to n')
  }
}

def main : IO Unit {
  let packet-size : Word = 20000n;

  let contents = repeat (fin-to-nat packet-size) 42n;

  let b : ByteVec _ = ..;

  let packet = byte-buffer-to-udp-packet b;

  let test-packet = mk-udp-packet
    2n
    3n
    packet-size
    5n
    contents;

  io-mapM_ (\i => {
    io-bind (debug-print i) (\_ => {
      let result = handle-packet i test-packet;

      case result {
        just r => debug-print r,
        nothing => {
          debug-print "No UDP packet!"
        }
      }
    })
  }) (count-to 2000)
}



repr ByteVecRepr {
  data ByteVec n as JS {
    bnil as js-buffer-alloc (repr 0),
    bcons x xs as {
      let xs' = repr xs;
      let old-len = js-buffer-byte-length xs';
      let new-len = js-plus old-len (repr 1);
      let b = js-buffer-alloc new-len;
      let b' = js-buffer-write-uint8 (repr x) (repr 0) b;
      js-buffer-copy xs' (repr 0) old-len (repr 1) b'
    },
    case l {
      bnil => n,
      bcons => c
    } as {
      let l' = repr l;
      js-if (js-eqq (js-buffer-byte-length l') (repr 0))
        (cast n)
        (cast (c (unrepr Fin (js-index l' (repr 0))) (unrepr ByteVec (js-buffer-subarray l' (repr 1) (js-buffer-byte-length l')))))
    }
  }
}

repr UdpRepr {
  data UdpPacket as JS {
    mk-udp-packet src-port dst-port len checksum contents as {
      let len' = repr len;
      let total-len = js-plus len' (repr 8);
      let b = js-buffer-alloc total-len;
      let b' = js-buffer-write-uint16-be (repr src-port) (repr 0) b;
      let b'' = js-buffer-write-uint16-be (repr dst-port) (repr 2) b';
      let b''' = js-buffer-write-uint16-be len' (repr 4) b'';
      let b'''' = js-buffer-write-uint16-be (repr checksum) (repr 6) b''';
      let b''''' = js-buffer-copy (repr contents) (repr 0) len' (repr 8) b'''';
      b'''''
    },
    case p {
      mk-udp-packet => mk,
    } as {
      let p' = repr p;
      let len = js-buffer-read-uint16-be (repr 4) p';
      cast (mk
        (unrepr Fin (js-buffer-read-uint16-be (repr 0) p'))
        (unrepr Fin (js-buffer-read-uint16-be (repr 2) p'))
        (unrepr Fin len)
        (unrepr Fin (js-buffer-read-uint16-be (repr 6) p'))
        (unrepr ByteVec (js-buffer-subarray (repr 8) (js-plus (repr 8) len) p')))
    }
  }
}


-- data Prod : Type -> Type -> Type {
--   mk-prod : [A : Type] -> [B : Type] -> A -> B -> Prod A B
-- }

-- def word-to-big-endian-bytes : Word -> Prod Byte Byte {
--   ?word-to-big-endian-bytes
-- }

-- def rec write-other-byte-vec : [n : Nat, l : Nat] -> (src : ByteVec l) -> (i : Fin n) -> (target : ByteVec (add l n)) -> ByteVec (add l n) {
--   \src i target => case i {
--     fz => case src {
--       bcons b src' => bcons b target
--     },
--     fs i' => case src {
--       bcons b src' => bcons b (write-other-byte-vec src' i' target)
--     }
--   }
-- }

-- def rec write-word-big-endian : (w : Word) -> [n : Nat] -> (i : Fin n) -> ByteVec (s (s n)) -> ByteVec (s (s n)) {
--   \w i xs => {
--     let bytes = word-to-big-endian-bytes w;
--     case bytes {
--       mk-prod b1 b2 => case i {
--         fz => case xs {
--           bcons b xs' => case xs' {
--             bcons b' xs'' => bcons b1 (bcons b2 xs'')
--           },
--         },
--         fs i' => case xs {
--           bcons b xs' => bcons b (write-word-big-endian w i' xs'),
--         }
--       }
--     }
--   }
-- }


-- def udp-packet-to-buffer : UdpPacket -> (l : Nat) * ByteVec (add 8 l) {
--   ?udp-packet-to-buffer
-- }

-- def buffer-to-udp-packet : [l : Nat] -> ByteVec (add 8 l) -> UdpPacket {
--   ?buffer-to-udp-packet
-- }
