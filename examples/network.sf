def field-len : Nat {
  pow 2 16
}

def byte-len : Nat {
  pow 2 16
}

def Word : Type {
  Fin field-len
}

data ByteVec : [n : Nat] -> Fin n -> Type {
  bnil : [n : Nat] -> ByteVec (fz [n]),
  bcons : [n : Nat] -> [i : Fin n] -> Fin byte-len -> ByteVec i -> ByteVec (fs i)
}

data UdpPacket : Type {
  mk-udp-packet :
    (src-port : Word) ->
    (dst-port : Word) ->
    (len : Word) ->
    (checksum : Word) ->
    (contents : ByteVec len) ->
    UdpPacket
}

def rec fin-is-even : [n : Nat] -> Fin n -> Bool {
  \x => case x {
    fz => true,
    fs x => case x {
      fz => false,
      fs y => fin-is-even y
    }
  }
}

def rec fin-eq : [n : Nat] -> [m : Nat] -> Fin n -> Fin m -> Bool {
  \a b => case a {
    fz => case b {
      fz => true,
      fs y => false
    },
    fs x => case b {
      fz => false,
      fs y => fin-eq x y
    }
  }
}

repr FinFns {
  def fin-is-even as \n => unrepr Bool (js-eqq (js-mod (repr n) js-two) js-zero)
  def fin-eq as \x y => unrepr Bool (js-eqq (repr x) (repr y))
}


def OWN_PORT : Word {
  4n
}

def rec max-fin : [n : Nat] -> Fin n -> Fin n -> Fin n {
  \x y => case x {
    fz => y,
    fs x' => case y {
      fz => x,
      fs y' => fs (max-fin x' y')
    }
  }
}

def handle-packet : UdpPacket -> Maybe UdpPacket {
  \p => case p {
    mk-udp-packet src-port dst-port len checksum contents => {
      -- The rule is, if the source port is even, forward the packet
      -- to the destination port, setting the source port to be our own.
      -- Otherwise, drop it.
      case fin-is-even src-port {
        true => {
          let new-p = mk-udp-packet OWN_PORT dst-port len checksum contents;
          just new-p
        },
        false => nothing
      }
    }
  }
}


def main : IO Unit {
  let test-packet = mk-udp-packet
    2n
    3n
    3n
    5n
    (bcons 1n (bcons 2n (bcons 3n bnil)));

  let result = handle-packet test-packet;

  io-bind
    (debug-print test-packet)
    (\_ => debug-print result)
}


repr ByteVecRepr {
  data ByteVec n as JS {
    bnil as js-buffer-alloc (repr 0),
    bcons x xs as {
      let xs' = repr xs;
      let old-len = js-buffer-byte-length xs';
      let new-len = js-plus old-len (repr 1);
      let b = js-buffer-alloc new-len;
      let b' = js-buffer-write-uint8 (repr x) (repr 0) b;
      js-buffer-copy xs' (repr 0) old-len (repr 1) b'
    },
    case l {
      bnil => n,
      bcons => c
    } as {
      let l' = repr l;
      js-if (js-eqq (js-buffer-byte-length l') (repr 0))
        (cast n)
        (cast (c (unrepr Fin (js-index l' (repr 0))) (unrepr ByteVec (js-buffer-subarray l' (repr 1) (js-buffer-byte-length l')))))
    }
  }
}

repr UdpRepr {
  data UdpPacket as JS {
    mk-udp-packet src-port dst-port len checksum contents as {
      let len' = repr len;
      let total-len = js-plus len' (repr 8);
      let b = js-buffer-alloc total-len;
      let b' = js-buffer-write-uint16-be (repr src-port) (repr 0) b;
      let b'' = js-buffer-write-uint16-be (repr dst-port) (repr 2) b';
      let b''' = js-buffer-write-uint16-be len' (repr 4) b'';
      let b'''' = js-buffer-write-uint16-be (repr checksum) (repr 6) b''';
      let b''''' = js-buffer-copy (repr contents) (repr 0) len' (repr 8) b'''';
      b'''''
    },
    case p {
      mk-udp-packet => mk,
    } as {
      let p' = repr p;
      let len = js-buffer-read-uint16-be (repr 4) p';
      let src-port = js-buffer-read-uint16-be (repr 0) p';
      let dst-port = js-buffer-read-uint16-be (repr 2) p';
      let checksum = js-buffer-read-uint16-be (repr 6) p';
      let contents = js-buffer-subarray (repr 8) (js-plus (repr 8) len) p';
      cast (mk (unrepr Fin src-port) (unrepr Fin dst-port) (unrepr Fin len) (unrepr Fin checksum) (unrepr ByteVec contents))
    }
  }
}
