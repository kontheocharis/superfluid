def two : Nat {
  s (s z)
}

def two_to_the_sixteen : Nat {
  pow two (pow two (pow two two))
}

def field-len : Nat {
  two_to_the_sixteen
}

def byte-len : Nat {
  two_to_the_sixteen
}

def Word : Type {
  Fin field-len
}

data ByteVec : [n : Nat] -> Fin n -> Type {
  bnil : [n : Nat] -> ByteVec (fz [n]),
  bcons : [n : Nat] -> [i : Fin n] -> Fin byte-len -> ByteVec i -> ByteVec (fs i)
}

data UdpPacket : Type {
  mk-udp-packet :
    (src-port : Word) ->
    (dst-port : Word) ->
    (len : Word) ->
    (checksum : Word) ->
    (contents : ByteVec len) ->
    UdpPacket
}

repr ByteVecRepr {
  data ByteVec n as JS {
    bnil as js-buffer-alloc (js-zero),
    bcons x xs as {
      let old-len = js-buffer-byte-length xs;
      let new-len = js-plus old-len js-one;
      let b = js-buffer-alloc new-len;
      let b' = js-buffer-write-uint8 b (to-js x) js-zero;
      js-buffer-copy b' js-one new-len xs js-zero old-len
    },
    case l {
      bnil => n,
      bcons => c
    } as {
      js-if (js-eqq (js-buffer-byte-length l) (js-zero))
        (cast n)
        (cast (c (cast (js-index l (js-zero))) (js-buffer-subarray l js-one (js-buffer-byte-length l))))
    }
  }
}



repr UdpRepr {
  data UdpPacket as JS {
    mk-udp-packet src-port dst-port len checksum contents as {
      let total-len = js-plus (cast len) js-eight;
      let b = js-buffer-alloc total-len;
      let b' = js-buffer-write-uint16-be (to-js src-port) js-zero b;
      let b'' = js-buffer-write-uint16-be (to-js dst-port) js-two b';
      let b''' = js-buffer-write-uint16-be (to-js len) js-four b'';
      let b'''' = js-buffer-write-uint16-be (to-js checksum) js-six b''';
      let b''''' = js-buffer-copy (to-js contents) js-zero (to-js len) js-eight b'''';
      b'''''
    },
    case p {
      mk-udp-packet => mk,
    } as {
      let len = js-buffer-read-uint16-be js-four p;
      cast (mk
        (cast (js-buffer-read-uint16-be js-zero p)) -- src-port
        (cast (js-buffer-read-uint16-be js-two p)) -- dst-port
        (cast len) -- len
        (cast (js-buffer-read-uint16-be js-six p)) -- checksum
        (cast (js-buffer-subarray js-eight (js-plus js-eight len) p))) -- contents
    }
  }
}

def rec fin-is-even : [n : Nat] -> Fin n -> Bool {
  \x => case x {
    fz => true,
    fs x => case x {
      fz => false,
      fs [m] y => fin-is-even [m] y
    }
  }
}

def rec fin-eq : [n : Nat] -> [m : Nat] -> Fin n -> Fin m -> Bool {
  \a b => case a {
    fz => case b {
      fz => true,
      fs y => false
    },
    fs [n] x => case b {
      fz => false,
      fs [m] y => fin-eq [n] [m] x y
    }
  }
}

repr FinFns {
  def fin-is-even as \n => js-eqq (js-mod n js-two) js-zero
  def fin-eq as \x y => js-eqq x y
}







def OWN_PORT : Word {
  fs (fs (fs (fs (fs (fs (fs (fs (fs (fs fz)))))))))
}

def handle-packet : UdpPacket -> Maybe UdpPacket {
  \p => case p {
    mk-udp-packet src-port dst-port len checksum contents => {
      -- The rule is, if the source port is even, forward the packet
      -- to the destination port, setting the source port to be our own.
      -- Otherwise, drop it.
      case fin-is-even src-port {
        true => {
          let new-p = mk-udp-packet OWN_PORT dst-port len checksum contents;
          just new-p
        },
        false => nothing
      }
    }
  }
}


def main : IO Unit {
  let test-packet = mk-udp-packet
    (fs (fs fz))
    (fs (fs (fs fz)))
    fz
    (fs (fs (fs (fs (fs fz)))))
    bnil;

  let result = handle-packet test-packet;

  io-bind
    (debug-print test-packet)
    (\_ => debug-print result)
}
