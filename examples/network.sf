def field-len : Nat {
  pow 2 16
}

def byte-len : Nat {
  pow 2 16
}

def Word : Type {
  Fin field-len
}

data ByteVec : [n : Nat] -> Fin n -> Type {
  bnil : [n : Nat] -> ByteVec (fz [n]),
  bcons : [n : Nat] -> [i : Fin n] -> Fin byte-len -> ByteVec i -> ByteVec (fs i)
}

data UdpPacket : Type {
  mk-udp-packet :
    (src-port : Word) ->
    (dst-port : Word) ->
    (len : Word) ->
    (checksum : Word) ->
    (contents : ByteVec len) ->
    UdpPacket
}

repr ByteVecRepr {
  data ByteVec n as JS {
    bnil as js-buffer-alloc (js-zero),
    bcons x xs as {
      let old-len = js-buffer-byte-length xs;
      let new-len = js-plus old-len js-one;
      let b = js-buffer-alloc new-len;
      let b' = js-buffer-write-uint8 b (to-js x) js-zero;
      js-buffer-copy xs js-zero old-len js-one b'
    },
    case l {
      bnil => n,
      bcons => c
    } as {
      js-if (js-eqq (js-buffer-byte-length l) (js-zero))
        (cast n)
        (cast (c (cast (js-index l (js-zero))) (js-buffer-subarray l js-one (js-buffer-byte-length l))))
    }
  }
}



repr UdpRepr {
  data UdpPacket as JS {
    mk-udp-packet src-port dst-port len checksum contents as {
      let total-len = js-plus (cast len) js-eight;
      let b = js-buffer-alloc total-len;
      let b' = js-buffer-write-uint16-be (to-js src-port) js-zero b;
      let b'' = js-buffer-write-uint16-be (to-js dst-port) js-two b';
      let b''' = js-buffer-write-uint16-be (to-js len) js-four b'';
      let b'''' = js-buffer-write-uint16-be (to-js checksum) js-six b''';
      let b''''' = js-buffer-copy (to-js contents) js-zero (to-js len) js-eight b'''';
      b'''''
    },
    case p {
      mk-udp-packet => mk,
    } as {
      let len = js-buffer-read-uint16-be js-four p;
      let src-port = js-buffer-read-uint16-be js-zero p;
      let dst-port = js-buffer-read-uint16-be js-two p;
      let checksum = js-buffer-read-uint16-be js-six p;
      let contents = js-buffer-subarray js-eight (js-plus js-eight len) p;
      cast (mk (cast src-port) (cast dst-port) (cast len) (cast checksum) (cast contents))
    }
  }
}

def rec fin-is-even : [n : Nat] -> Fin n -> Bool {
  \x => case x {
    fz => true,
    fs x => case x {
      fz => false,
      fs [m] y => fin-is-even [m] y
    }
  }
}

def rec fin-eq : [n : Nat] -> [m : Nat] -> Fin n -> Fin m -> Bool {
  \a b => case a {
    fz => case b {
      fz => true,
      fs y => false
    },
    fs [n] x => case b {
      fz => false,
      fs [m] y => fin-eq [n] [m] x y
    }
  }
}

repr FinFns {
  def fin-is-even as \n => js-eqq (js-mod n js-two) js-zero
  def fin-eq as \x y => js-eqq x y
}


def OWN_PORT : Word {
  4n
}

def handle-packet : UdpPacket -> Maybe UdpPacket {
  \p => case p {
    mk-udp-packet src-port dst-port len checksum contents => {
      -- The rule is, if the source port is even, forward the packet
      -- to the destination port, setting the source port to be our own.
      -- Otherwise, drop it.
      case fin-is-even src-port {
        true => {
          let new-p = mk-udp-packet OWN_PORT dst-port len checksum contents;
          just new-p
        },
        false => nothing
      }
    }
  }
}


def main : IO Unit {
  let test-packet = mk-udp-packet
    2n
    3n
    0n
    5n
    bnil;

  let result = handle-packet test-packet;

  io-bind
    (debug-print test-packet)
    (\_ => debug-print result)
}
