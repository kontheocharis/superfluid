-- Foo

data Bool : Type {
  true : Bool,
  false : Bool,
}

data Equal : (A : Type) -> A -> A -> Type {
  refl : (A : Type) -> (x : A) -> Equal A x x
}

def if-then-else : (T : Type) -> Bool -> T -> T -> T {
  \T b t e => case b {
    true => t,
    false => e,
  }
}

def if-then-else-dep : (T : Bool -> Type) -> (b : Bool) -> T true -> T false -> T b {
  \T b t e => case b {
    true => t,
    false => e,
  }
}

def if-then-else-eq : (T : Type) -> (b : Bool) -> (Equal Bool b true -> T) -> (Equal Bool b false -> T) -> T {
  \T b t e => case b {
    true => t (refl _ _),
    false => e (refl _ _),
  }
}

data Word : Type {
  zw : Word,
  sw : Word -> Word,
}

def word-zero : Word {
  zw
}

def word-add : Word -> Word -> Word {
  \m n => case m {
    zw => n,
    sw m' => sw (word-add m' n),
  }
}

def word-one : Word {
  sw zw
}

def word-is-zero : Word -> Bool {
  \m => case m {
    zw => true,
    sw m' => false,
  }
}

def word-sub : Word -> Word -> Word {
  \m n => case n {
    zw => m,
    sw n' => case m {
      zw => zw,
      sw m' => word-sub m' n',
    },
  }
}

def switch-word : (F : Word -> Type) -> F word-zero -> ((w : Word) -> F (word-add w word-one)) -> (w : Word) -> F w {
  ?h2
}

---

data Nat : Type {
  z : Nat,
  s : Nat -> Nat,
}

def add : Nat -> Nat -> Nat {
  \m n => case m {
    z => n,
    s m' => s (add m' n),
  }
}

repr NatWord {
  data Nat as Word {
    z as word-zero,
    s n as word-add n word-one,
    case n {
      z => b,
      s => r,
    } as (
      switch-word _ b r n
    )
  }

  def add as word-add
}

def fib : Nat -> Nat {
  \n => case n {
    z => z,
    s i => case i {
      z => s z,
      s j => add (fib i) (fib j),
    },
  }
}
