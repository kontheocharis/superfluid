
-- LOW LEVEL TYPES
-- Never mind their implementations, these are opaque (TODO: Add definitions without implementations)

data Unit : Type {
  unit : Unit
}

def TT : Unit {
  unit
}

data FlatArray : Type -> Type {
  flat-nil : [A : Type] -> FlatArray A,
  flat-cons : [A : Type] -> A -> FlatArray A -> FlatArray A
}

data Bool : Type {
  true : Bool,
  false : Bool
}

def TRUE : Bool {
  true
}
def FALSE : Bool {
  false
}

def if-then-else : [A : Type] -> Bool -> (Unit -> A) -> (Unit -> A) -> A {
  \b t e => case b {
    true => t TT,
    false => e TT
  }
}

data Size : Type {
  zero : Size,
  succ : Size -> Size
}

def ZERO : Size {
  zero
}

def ONE : Size {
  succ zero
}

def add : Size -> Size -> Size {
  \s1 s2 => case s1 {
    zero => s2,
    succ s1' => succ (add s1' s2)
  }
}

def sub : Size -> Size -> Size {
  \s1 s2 => case s2 {
    zero => s1,
    succ s2' => case s1 {
      zero => zero,
      succ s1' => sub s1' s2'
    }
  }
}

def len : [A : Type] -> FlatArray A -> Size {
  \arr => case arr {
    flat-nil => zero,
    flat-cons _ arr => succ (len arr)
  }
}

def is-zero : Size -> Bool {
  \s => case s {
    zero => true,
    succ _ => false
  }
}

def is-one : Size -> Bool {
  \s => case s {
    zero => false,
    succ s' => case s' {
      zero => true,
      succ _ => false
    }
  }
}

def slice : [A : Type] -> FlatArray A -> Size -> Size -> FlatArray A {
  \arr start end => case start {
    zero => case end {
      zero => flat-nil,
      succ end' => case arr {
        flat-nil => flat-nil,
        flat-cons x arr' => flat-cons x (slice arr' zero end')
      }
    },
    succ start' => case arr {
      flat-nil => flat-nil,
      flat-cons _ arr' => slice arr' start' end
    }
  }
}

def unsafe-cast : [A : Type] -> [B : Type] -> A -> B {
  ?unsafe-cast
}

def push-front : [A : Type] -> A -> FlatArray A -> FlatArray A {
  \x arr => flat-cons x arr
}

def push-back : [A : Type] -> A -> FlatArray A -> FlatArray A {
  \x arr => case arr {
    flat-nil => flat-cons x (flat-nil),
    flat-cons y arr' => flat-cons y (push-back x arr')
  }
}

def empty : [A : Type] -> FlatArray A {
  flat-nil
}

def index : [A : Type] -> FlatArray A -> Size -> A {
  \arr i => case i {
    zero => case arr {
      flat-nil => ?index-out-of-bounds,
      flat-cons x _ => x
    },
    succ i' => case arr {
      flat-nil => ?index-out-of-bounds,
      flat-cons _ arr' => index arr' i'
    }
  }
}

-- HIGH LEVEL TYPES

def id : [A : Type] -> A -> A {
  \x => x
}

data List : Type -> Type {
  nil : [A : Type] -> List A,
  cons : [A : Type] -> A -> List A -> List A
}

data SnocList : Type -> Type {
  lin : [A : Type] -> SnocList A,
  snoc : [A : Type] -> SnocList A -> A -> SnocList A
}

def append-snoc : [A : Type] -> SnocList A -> SnocList A -> SnocList A {
  \l1 l2 => case l2 {
    lin => l1,
    snoc l2' x => snoc (append-snoc l1 l2') x
  }
}

def append : [A : Type] -> List A -> List A -> List A {
  \l1 l2 => case l1 {
    nil => l2,
    cons x xs => cons x (append xs l2)
  }
}

def last : [A : Type] -> A -> List A -> A {
  \x xs => case xs {
    nil => x,
    cons y ys => last y ys
  }
}

def init : [A : Type] -> A -> List A -> List A {
  \x xs => case xs {
    nil => nil,
    cons y ys => cons x (init y ys)
  }
}

def to-snoc : [A : Type] -> List A -> SnocList A {
  \l => case l {
    nil => lin,
    cons x xs => append-snoc (snoc lin x) (to-snoc xs)
  }
}

def from-snoc : [A : Type] -> SnocList A -> List A {
  \l => case l {
    lin => nil,
    snoc l' x => append (from-snoc l') (cons x nil)
  }
}

data Eq : Type -> Type {
  mk-eq : [A : Type] -> (is-equal : A -> A -> Bool) -> Eq A
}

def is-equal : [A : Type] -> Eq A -> A -> A -> Bool {
  \eq x y => case eq {
    mk-eq is-equal' => is-equal' x y
  }
}

data DoubleList : Type -> Type {
  double-nil : [A : Type] -> DoubleList A,
  double-one : [A : Type] -> A -> DoubleList A,
  double-cons : [A : Type] -> A -> List A -> A -> DoubleList A
}

def to-double : [A : Type] -> List A -> DoubleList A {
  \l => case l {
    nil => double-nil,
    cons x xs => case to-snoc xs {
      lin => double-one x,
      snoc ys y => double-cons x (from-snoc ys) y
    }
  }
}

def is-palindrome : [A : Type] -> Eq A -> List A -> Bool {
  \eq l => case to-double l {
    double-nil => true,
    double-one _ => true,
    double-cons x xs y => if-then-else (is-equal eq x y)
      (\_ => is-palindrome eq xs)
      (\_ => false)
  }
}

-- OUTPUT:
--
-- def is-palindrome : (A : Type) -> (n190 : Eq A) -> (n191 : FlatArray A) -> Bool {
--   \A eq l => {
--     let l' : FlatArray A = l;
--     if-then-else _ (is-zero (len _ l'))
--     (\_ => true)
--     (\_ => if-then-else _ (is-one (len _ l'))
--       (\_ => true)
--       (\_ => if-then-else _ (is-equal _ eq (index _ l' ZERO) (index _ l' (sub (len _ l') ONE)))
--         (\_ => is-palindrome _ eq (slice _ l' ONE (sub (len _ l') ONE)))
--         (\_ => false)))
--   }
-- }

-- REPRESENTATIONS

repr FlatLists {
  data List A as FlatArray A {
    nil as empty,
    cons x xs as push-front x xs,

    case l {
      nil => b,
      cons => r
    } as {
      if-then-else (is-zero (len l))
        (\_ => unsafe-cast b)
        (\_ => unsafe-cast (r (index l ZERO) (slice l ONE (len l))))
    }
  }

  data SnocList A as FlatArray A {
    lin as empty,
    snoc xs x as push-back x xs,

    case l {
      lin => b,
      snoc => r
    } as {
      if-then-else (is-zero (len l))
        (\_ => unsafe-cast b)
        (\_ => unsafe-cast (r (slice l ZERO (sub (len l) ONE)) (index l (sub (len l) ONE))))
    }
  }

  data DoubleList A as FlatArray A {
    double-nil as empty,
    double-one x as push-front x empty,
    double-cons x xs y as push-front x (push-back y xs),

    case l {
      double-nil => b,
      double-one => r1,
      double-cons => r2
    } as {
      if-then-else (is-zero (len l))
        (\_ => unsafe-cast b)
        (\_ => if-then-else (is-one (len l))
          (\_ => unsafe-cast (r1 (index l ZERO)))
          (\_ => unsafe-cast
            (r2 (index l ZERO)
              (slice l ONE (sub (len l) ONE))
              (index l (sub (len l) ONE)))))
    }
  }

  def to-snoc as \x => x

  def from-snoc as \x => x

  def to-double as \x => x
}
