def nat-fold-range : [A : Type] -> (Nat * Nat) -> A -> (Nat -> A -> A) -> A {
  \(start, end) init f => {
    if lt start end {
      nat-fold-range (s start, end) (f start init) f
    } else {
      init
    }
  }
}

def sum-of-divisors : Nat -> Nat {
  \n => nat-fold-range (1, s (div n 2)) 0 (\i acc => {
    if nat-eq (mod n i) 0 {
      add acc i
    } else {
      acc
    }
  })
}

data FriendlyPair : Nat -> Nat -> Type {
  friendly : (a : Nat, b : Nat) ->
    Equal (sum-of-divisors a) b ->
    Equal (sum-of-divisors b) a ->
    FriendlyPair a b
}

-- Decision procedure for FriendlyPair
def is-friendly-pair : (a : Nat, b : Nat) -> Dec (FriendlyPair a b) {
  \a b => {
    let sum-a = sum-of-divisors a;
    let sum-b = sum-of-divisors b;
    case nat-eq-dep sum-a b {
      yes p1 => case nat-eq-dep sum-b a {
        yes p2 => yes (friendly a b p1 p2),
      no p2 => {
          let contr : FriendlyPair a b -> Empty = \f => case f {
            friendly a' b' p q => p2 q,
          };
          ?nocontr2
        }
      },
      no p1 => {
        let contr : FriendlyPair a b -> Empty = \(friendly _ _ p q) => ?h312;
        ?nocontr
      }
    }
  }
}

def main : IO () {
  case is-friendly-pair 284 221 {
    yes _ => io-return (debug-print "Friendly!" tt),
    no _ => io-return (debug-print "Not friendly!" tt)
  }
}

-- def test : FriendlyPair 220 284 {
--   friendly 220 284 refl refl
-- }

-- def check-friendly-pair : (a : Nat) -> (b : Nat) -> String {
--   \a b =>
--     case is-friendly-pair a b {
--       yes _ => "The numbers form an friendly pair",
--       no _ => "The numbers do not form an friendly pair"
--     }
-- }

-- -- Example usage
-- def main : IO () {
--   \_ => {
--     print-string "Enter the first number: ";
--     let a <- read-nat;
--     print-string "Enter the second number: ";
--     let b <- read-nat;
--     result <- check-friendly-pair a b;
--     print-string result
--   }
-- }
