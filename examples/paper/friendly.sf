def nat-fold-range : [A : Type] -> (Nat * Nat) -> A -> (Nat -> A -> A) -> A {
  \(start, end) init f => {
    if lt start end {
      nat-fold-range (s start, end) (f start init) f
    } else {
      init
    }
  }
}

def sum-of-divisors : Nat -> Nat {
  \n => nat-fold-range (1, s (div n 2)) 0 (\i acc => {
    if nat-eq (mod n i) 0 {
      add acc i
    } else {
      acc
    }
  })
}

data FriendlyPair : Nat -> Nat -> Type {
  friendly : (a : Nat, b : Nat) ->
    Equal (sum-of-divisors a) b ->
    Equal (sum-of-divisors b) a ->
    FriendlyPair a b
}

-- Decision procedure for FriendlyPair
def is-friendly-pair : (a : Nat, b : Nat) -> Maybe (FriendlyPair a b) {
  \a b => {
    let sum-a = sum-of-divisors a;
    let sum-b = sum-of-divisors b;
    case nat-eq-dep sum-a b {
      yes p1 => case nat-eq-dep sum-b a {
        yes p2 => just (friendly a b p1 p2),
        no _ => nothing
      },
      no _ => nothing
    }
  }
}

def main : IO () {
case is-friendly-pair 284 221 {
    nothing => io-return (debug-print "Not friendly!" tt),
    just _ => io-return (debug-print "Friendly!" tt)
  }
}

def test : FriendlyPair 28 28 {
  friendly _ _ refl refl
}

-- def check-friendly-pair : (a : Nat) -> (b : Nat) -> String {
--   \a b =>
--     case is-friendly-pair a b {
--       yes _ => "The numbers form an friendly pair",
--       no _ => "The numbers do not form an friendly pair"
--     }
-- }

-- -- Example usage
-- def main : IO () {
--   \_ => {
--     print-string "Enter the first number: ";
--     let a <- read-nat;
--     print-string "Enter the second number: ";
--     let b <- read-nat;
--     result <- check-friendly-pair a b;
--     print-string result
--   }
-- }
