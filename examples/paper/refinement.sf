data Vec (T : Type) : Nat -> Type {
  vec-nil : Vec T z,
  vec-cons : [n : Nat] -> T -> Vec T n -> Vec T (s n)
}

def vec-length : [T : Type, * n : Nat] -> Vec T n -> Nat {
  \[_] [n] _ => n
}

data RISigma (A : Type) (B : A -> Type) : Type {
  ri-pair : (a : A) -> (0 _ : B a) -> RISigma A B
}

def ri-fst : [A : Type, B : A -> Type] -> (x : RISigma A B) -> A {
  \(ri-pair x _) => x
}

def 0 ri-snd : [A : Type, B : A -> Type] -> (x : RISigma A B) -> B (ri-fst x) {
  \[_] [B] p => case p to (\p => B (ri-fst p)) {
    (ri-pair a b) => b
  }
}

def 0 ri-sigma-eta : [A : Type, B : A -> Type] -> [x : RISigma A B] -> Equal x (ri-pair (ri-fst x) (ri-snd x)) {
  \[x] => case x to (\x => Equal x (ri-pair (ri-fst x) (ri-snd x))) {
    (ri-pair a b) => refl
  }
}

repr data Vec T n as RISigma (List T) (\l => Equal (length l) n) {
  vec-nil as ri-pair nil refl,
  vec-cons x xs as {
    let (ri-pair xs' p) = repr xs;
    ri-pair (cons x xs') (cong s p)
  },

  case b to E {
    vec-nil => ni,
    vec-cons => co
  } as {
    let b' = repr b;
    let l = ri-fst b';
    let 0 p = ri-snd b';
    let n = vec-length b;

    subst
      (\t => E n (unrepr t)) (sym ri-sigma-eta)
      ((case l to (\l => (p : Equal (length l) n) -> E n (unrepr (ri-pair l p))) {
        nil => case n to (\n' => (p : Equal z n') -> E n' (unrepr (ri-pair nil p))) {
          z => \p => subst (\p' => E z (unrepr (ri-pair nil p'))) (sym (uip p)) ni,
          s n' => \p => case z-neq-s p {},
        },
        cons x xs => case n to (\n' => (p : Equal (s (length xs)) n') -> E n' (unrepr (ri-pair (cons x xs) p))) {
          z => \p => case z-neq-s (sym p) {},
          s n'' => \p => {
            subst (\p' => E (s n'') (unrepr (ri-pair (cons x xs) p')))
              (equality-is-prop (cong s (s-inj p)) p)
              (co x (unrepr (ri-pair xs (s-inj p))))
          }
        },
      }) p)
  }
}
