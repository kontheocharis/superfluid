data Vec (T : Type) : Nat -> Type {
  vec-nil : Vec T z,
  vec-cons : [n : Nat] -> T -> Vec T n -> Vec T (s n)
}

def vec-length : [T : Type, * n : Nat] -> Vec T n -> Nat {
  \[_] [n] _ => n
}

data RISigma (A : Type) (B : A -> Type) : Type {
  ri-pair : (a : A) -> (0 _ : B a) -> RISigma A B
}

repr data Vec T n as RISigma (List T) (\l => Equal (length l) n) {
  vec-nil as ri-pair nil refl,
  vec-cons x xs as {
    let (ri-pair xs' p) = repr xs;
    ri-pair (cons x xs') (cong s p)
  },

  case b to E {
    vec-nil => ni,
    vec-cons => co
  } as {
    let (ri-pair l p) = repr b;
    let q : Equal (ri-pair l p) (repr b) = trust-me;
    let n = vec-length b;
    subst
      (\t => E n (unrepr t)) q
      ((case l to (\l => (p : Equal (length l) n) -> E n (unrepr (ri-pair l p))) {
        nil => case n to (\n' => (p : Equal z n') -> E n' (unrepr (ri-pair nil p))) {
          z => \p => subst (\p' => E z (unrepr (ri-pair nil p'))) (sym (uip p)) ni,
          s n' => \p => case z-neq-s p {},
        },
        cons x xs => case n to (\n' => (p : Equal (s (length xs)) n') -> E n' (unrepr (ri-pair (cons x xs) p))) {
          z => \p => case z-neq-s (sym p) {},
          s n'' => \p => {
            subst (\p' => E (s n'') (unrepr (ri-pair (cons x xs) p')))
              (equality-is-prop (cong s (s-inj p)) p)
              (co x (unrepr (ri-pair xs (s-inj p))))
          }
        },
      }) p)
  }
}
