data Vec (T : Type) : Nat -> Type {
  vec-nil : Vec T z,
  vec-cons : [n : Nat] -> T -> Vec T n -> Vec T (s n)
}

def vec-length : [T : Type, * n : Nat] -> Vec T n -> Nat {
  \[_] [n] _ => n
}

data RISigma (A : Type) (B : A -> Type) : Type {
  ri-pair : (a : A) -> (0 _ : B a) -> RISigma A B
}

-- #unfold
def ri-fst : [A : Type, B : A -> Type] -> (x : RISigma A B) -> A {
  \x => case x {
    ri-pair a b => a
  }
}

#unfold
def 0 ri-snd : [A : Type, B : A -> Type] -> (x : RISigma A B) -> B (ri-fst x) {
  \[_] [B] p => case p to (\p => B (ri-fst p)) {
    (ri-pair a b) => b
  }
}

#unfold
def 0 ri-sigma-eta : [A : Type, B : A -> Type] -> [x : RISigma A B] -> Equal x (ri-pair (ri-fst x) (ri-snd x)) {
  \[x] => case x to (\x => Equal x (ri-pair (ri-fst x) (ri-snd x))) {
    (ri-pair a b) => refl
  }
}

def 0 Vec' : Type -> Nat -> Type {
  \T n => RISigma (List T) (\l => Equal (length l) n)
}

#unfold
def vec-nil' : [T : Type] -> Vec' T 0 {
  ri-pair nil refl
}

#unfold
def vec-cons' : [T : Type, n : Nat] -> T -> Vec' T n -> Vec' T (s n) {
  \[T] [n] x xs => {
    ri-pair (cons x (ri-fst xs)) (cong s (ri-snd xs))
  }
}

#unfold
def vec-ind' : [T : Type] -> (E : (0 n : Nat) -> Vec' T n -> Type)
    -> E 0 vec-nil'
    -> ((x : T) -> [n : Nat] -> (xs : Vec' T n) -> E (s n) (vec-cons' x xs))
    -> [* n : Nat] -> (b : Vec' T n) -> E n b
{
  \E ni co [n] b' => {
    let l = ri-fst b';
    let 0 p = ri-snd b';

    subst
      (\t => E n t) (sym ri-sigma-eta)
      ((case l to (\l => (p : Equal (length l) n) -> E n (ri-pair l p)) {
        nil => case n to (\n' => (p : Equal z n') -> E n' (ri-pair nil p)) {
          z => \p => subst (\p' => E z (ri-pair nil p')) (sym (uip p)) ni,
          s n' => \p => case z-neq-s p {},
        },
        cons x xs => case n to (\n' => (p : Equal (s (length xs)) n') -> E n' (ri-pair (cons x xs) p)) {
          z => \p => case z-neq-s (sym p) {},
          s n'' => \p => {
            subst (\p' => E (s n'') (ri-pair (cons x xs) p'))
              (equality-is-prop (cong s (s-inj p)) p)
              (co x (ri-pair xs (s-inj p)))
          }
        },
      }) p)
  }
}

-- these are almost refl, but blocked by annoying things

def 0 vec-ind-nil' :  [T : Type] -> [E : (0 n : Nat) -> Vec' T n -> Type]
    -> [ni : E 0 vec-nil']
    -> [co : ((x : T) -> [n : Nat] -> (xs : Vec' T n) -> E (s n) (vec-cons' x xs))]
    -> Equal (vec-ind' E ni co vec-nil') ni
{
  ?vec-ind-nil'
}

def 0 vec-ind-cons' :  [T : Type] -> [E : (0 n : Nat) -> Vec' T n -> Type]
    -> [ni : E 0 vec-nil']
    -> [co : ((x : T) -> [n : Nat] -> (xs : Vec' T n) -> E (s n) (vec-cons' x xs))]
    -> [* n : Nat] -> (x : T) -> (xs : Vec' T n)
    -> Equal (vec-ind' E ni co (vec-cons' x xs)) (co x xs)
{
  \x xs => ?vec-ind-cons'
}


repr data Vec T n as Vec' T n {
  vec-nil as vec-nil',
  vec-cons x xs as vec-cons' x (repr xs),

  case b to E {
    vec-nil => ni,
    vec-cons => co
  } as {
    vec-ind' (\n v => E n (unrepr v)) ni (\x xs => co x (unrepr xs)) (repr b)
  }
}

def 0 fin-zero-absurd : Fin 0 -> Empty {
  \i => (case i to (\n _ => Equal 0 n -> Empty) {
    fz => z-neq-s,
    fs _ => z-neq-s,
  }) refl
}

def vec-index : [T : Type, n : Nat] -> Vec T n -> Fin n -> T {
  \v => case v to (\n _ => Fin n -> T) {
    vec-nil => \i => case fin-zero-absurd i {},
    vec-cons [n'] x xs => \i => (case i to (\n _ => Equal (s n') n -> T) {
      fz => \_ => x,
      fs i' => \p => {
        let p' = s-inj p;
        vec-index xs (subst (\i => Fin i) (sym p') i')
      },
    }) refl
  }
}

def safe-index : [T : Type, n : Nat] -> (l : List T) -> 0 Equal (length l) n -> (i : Fin n) -> T {
  \l p i => vec-index (unrepr (ri-pair l p)) i
}

def vec-to-list : [T : Type, n : Nat] -> Vec T n -> List T {
  \v => case v to (\n _ => List T) {
    vec-nil => nil,
    vec-cons x xs => cons x (vec-to-list xs)
  }
}

repr def vec-to-list as \v => ri-fst (repr v)

def main : IO () {
  let v = vec-cons 1 vec-nil;
  let n = vec-index v 0n;
  js-console-log n
}
