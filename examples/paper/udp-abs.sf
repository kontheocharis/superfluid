
data IPPacketHeader : Type {
  mk-ip-packet : (
    src-ip : Word,
    dst-ip : Word,
    protocol : Word,
    len : Word,
  ) -> IPPacketHeader
}

data TcpPacketHeader : Type {
  mk-tcp-packet-header : (
    src-port : Word,
    dst-port : Word,
    seq : Word,
    ack : Word,
    checksum : Word,
    len : Word,
  ) -> TcpPacketHeader
}

def tcp-packet-len : TcpPacketHeader -> Word {
  \case {
    mk-tcp-packet-header src-port dst-port seq ack checksum len => len
  }
}

data ByteVec : Nat -> Type {
  bnil : ByteVec z,
  bcons : [n : Nat] -> Byte -> ByteVec n -> ByteVec (s n)
}

def repr-subst : [A B : Type] -> Equal (repr A) B -> repr A -> B {
  \p a => {
    subst [Type] (\X => X) p a
  }
}

def repr-subst' : [A B : Type] -> Equal (repr A) B -> B -> repr A {
  \p a => {
    subst [Type] (\X => X) (sym p) a
  }
}

def Reprs : Nat -> Type -> Type {
  \l T => case l {
    z => T,
    s l' => repr (Reprs l' T)
  }
}

def reprs : [T : Type] -> (l : Nat) -> T -> Reprs l T {
  \l t => case l to (\l => Reprs l T) {
    z => t,
    s l' => repr (reprs l' t)
  }
}

def ReprBy : Type -> Type -> Type {
  \T U => (l : Nat) * Equal (Reprs l T) U
}

def IsFlatN : Type -> Nat -> Type {
  \T n => ReprBy T (ByteVec n)
}

def IsFlat : Type -> Type {
  \T => (n : Nat) * IsFlatN T n
}

def IsFlatDep : (Nat -> Type) -> Type {
  \T => ((n : Nat) -> IsFlatN (T n) n)
}

data Packet (H : Type) (flat-h : IsFlat H) (len : H -> Nat) (C : Nat -> Type) (flat-c : IsFlatDep C) : Type {
  mk-packet : (header : H) (contents : C (len header)) -> Packet H flat-h len C flat-c
}

repr data TcpPacketHeader as ByteVec 20 {
  mk-tcp-packet-header src-port dst-port seq ack checksum as ?h1
  case s {
    mk-tcp-packet-header => mk,
  } as ?h2
}

def TcpPacket : (C : Nat -> Type) (flat-c : IsFlatDep C) -> Type {
  Packet TcpPacketHeader (20, (1, refl)) (\p => word-to-nat (tcp-packet-len p))
}

