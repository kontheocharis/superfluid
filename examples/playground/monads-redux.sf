data Functor (F : Type -> Type) : Type {
  functor : (map : [A B : Type] -> (A -> B) -> (F A -> F B)) -> Functor F
}

data Monad (M : Type -> Type) : Type {
  monad : [[Functor M]] (
    return : [A : Type] -> A -> M A,
    bind : [A : Type] -> [B : Type] -> M A -> (A -> M B) -> M B
  ) -> Monad M
}

#unfold
def monad-functor : [M : Type -> Type] [[Monad M]] -> Functor M {
  \[[m]] => case m {
    monad [[f]] r b => f
  }
}

#unfold
def return : [M : Type -> Type] [[Monad M]] [A : Type] -> A -> M A {
  \[[m]] => case m {
    monad r b => r
  }
}

#unfold
def bind : [M : Type -> Type] [[Monad M]] [A B : Type] -> M A -> (A -> M B) -> M B {
  \[[m]] => case m {
    monad r b => b
  }
}

#unfold
def fmap : [F : Type -> Type] [[Functor F]] [A B : Type] -> (A -> B) -> (F A -> F B) {
  \[[f]] => case f {
    functor m => m
  }
}

#instance
def maybe-is-functor : Functor Maybe {
  ?m
}

#instance
def maybe-is-monad : Monad Maybe {
  ?m
}


#instance
def list-is-functor : Functor List {
  ?m
}

#instance
def list-is-monad : Monad List {
  ?m
}

def main2 : Maybe Nat {
  let x <- return 4;
  let m <- return (add 3 x);
  return m
}

-- def main : () {
--   let x = fmap s (bind (return 3) (\n => return (add 3 n)));
--   ()
-- }

-- def bind : [M : Type -> Type] -> Monad M -> [A : Type] -> [B : Type] -> M A -> (A -> M B) -> M B {
--   \m => case m {
--     mk-monad _ _ _ b => b
--   }
-- }

-- def fmap : [F : Type -> Type] -> Functor F -> [A : Type] -> [B : Type] -> (A -> B) -> (F A -> F B) {
--   \m => case m {
--     mk-functor _ f => f
--   }
-- }
