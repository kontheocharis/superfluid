
data Vec : Type -> Nat -> Type {
  vnil : [A : Type] -> Vec A z,
  vcons : [A : Type, n : Nat] -> A -> Vec A n -> Vec A (s n),
}

def repeat : [A : Type] -> (n : Nat) -> A -> Vec A n {
  \n a => case n {
    z => vnil,
    s n' => vcons a (repeat n' a),
  }
}

def map : [A : Type, B : Type, n : Nat] -> (A -> B) -> Vec A n -> Vec B n {
  \f v => case v {
    vnil => vnil,
    vcons x xs => vcons (f x) (map f xs),
  }
}

def main : (n : Nat) * Vec Nat n {
  (1, vnil)
}



-- check mk-pair [?1] [?2] tt tt : Unit * Unit

-- involves:

-- infer pair => [A : Type, B : Type] -> (x : A) -> B x -> Sigma A B
-- infer pair [?1] => [B : Type] -> (x : ?1) -> B -> Sigma ?1 B
-- infer pair [?1] [?2] => (x : ?1) -> ?2 x -> Sigma ?1 ?2
-- infer pair [Unit] [?2] tt => ?2 tt -> Sigma Unit ?2


-- infer pair [?1] [?2] tt tt => Unit * Unit


