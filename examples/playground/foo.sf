-- data Vec : Type -> Nat -> Type {
--   vnil : [A : Type] -> Vec A z,
--   vcons : [A : Type, n : Nat] -> A -> Vec A n -> Vec A (s n),
-- }

-- def repeat : [A : Type] -> (n : Nat) -> A -> Vec A n {
--   \n a => case n {
--     z => vnil,
--     s n' => vcons a (repeat n' a),
--   }
-- }

-- def upgrade1 : [n : Nat] -> Fin n -> Fin (s n) {
--   \f => case f {
--     fz => fz,
--     fs f' => fs (upgrade1 f'),
--   }
-- }

-- def plus-succ-symmetric : [m n : Nat] -> Equal (add (s m) n) (add m (s n)) {
--   \[m] [n] => case m {
--     z => refl,
--     s m' => cong s (plus-succ-symmetric [m'] [n]),
--   }
-- }

-- def upgrade-i : [n : Nat] -> (i : Nat) -> Fin n -> Fin (add i n) {
--   \i f => case i {
--     z => f,
--     s i' => ?h2,
--   }
-- }

-- def main : Nat -> (n : Nat) * Vec Nat n {
--   \n => (n, repeat n z)
-- }



-- check mk-pair [?1] [?2] tt tt : Unit * Unit

-- involves:

-- infer pair => [A : Type, B : Type] -> (x : A) -> B x -> Sigma A B
-- infer pair [?1] => [B : Type] -> (x : ?1) -> B -> Sigma ?1 B
-- infer pair [?1] [?2] => (x : ?1) -> ?2 x -> Sigma ?1 ?2
-- infer pair [Unit] [?2] tt => ?2 tt -> Sigma Unit ?2


-- infer pair [?1] [?2] tt tt => Unit * Unit



-- -- Default representations
