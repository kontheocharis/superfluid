
-- data Vec : Type -> Nat -> Type {
--   vnil : [A : Type] -> Vec A z,
--   vcons : [A : Type, n : Nat] -> A -> Vec A n -> Vec A (s n),
-- }

-- data Elem : [A : Type, n : Nat] -> (i : Fin n) -> A -> Vec A n -> Type {
--   here : [A : Type, i : Nat, x : A, xs : Vec A i] -> Elem (s i) x (vcons x xs),
-- }

-- def repeat : [A : Type] -> (n : Nat) -> A -> Vec A n {
--   \n a => case n {
--     z => vnil,
--     s n' => vcons a (repeat n' a),
--   }
-- }

-- def map : [A : Type, B : Type, n : Nat] -> (A -> B) -> Vec A n -> Vec B n {
--   \f v => case v {
--     vnil => vnil,
--     vcons x xs => vcons (f x) (map f xs),
--   }
-- }

def main : Unit -> Unit {
  let y = tt;
  \_ => (\x => x) y
}




-- check mk-pair [?1] [?2] tt tt : Unit * Unit

-- involves:

-- infer pair => [A : Type, B : Type] -> (x : A) -> B x -> Sigma A B
-- infer pair [?1] => [B : Type] -> (x : ?1) -> B -> Sigma ?1 B
-- infer pair [?1] [?2] => (x : ?1) -> ?2 x -> Sigma ?1 ?2
-- infer pair [Unit] [?2] tt => ?2 tt -> Sigma Unit ?2


-- infer pair [?1] [?2] tt tt => Unit * Unit


