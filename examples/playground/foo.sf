
data Vec : Type -> Nat -> Type {
  vnil : [A : Type] -> Vec A z,
  vcons : [A : Type, n : Nat] -> A -> Vec A n -> Vec A (s n),
}

def repeat : [A : Type] -> (n : Nat) -> A -> Vec A n {
  \n a => case n {
    z => vnil,
    s n' => vcons a (repeat n' a),
  }
}

def upgrade1 : [n : Nat] -> Fin n -> Fin (s n) {
  \f => case f {
    fz => fz,
    fs f' => fs (upgrade1 f'),
  }
}

def plus-succ-symmetric : [m n : Nat] -> Equal (add (s m) n) (add m (s n)) {
  \[m] [n] => case m {
    z => refl,
    s m' => cong s (plus-succ-symmetric [m'] [n]),
  }
}

def upgrade-i : [n : Nat] -> (i : Nat) -> Fin n -> Fin (add i n) {
  \i f => case i {
    z => f,
    s i' => ?h2,
  }
}

def main : (n : Nat) * Vec Nat n {
  (1, vcons z vnil)
}



-- check mk-pair [?1] [?2] tt tt : Unit * Unit

-- involves:

-- infer pair => [A : Type, B : Type] -> (x : A) -> B x -> Sigma A B
-- infer pair [?1] => [B : Type] -> (x : ?1) -> B -> Sigma ?1 B
-- infer pair [?1] [?2] => (x : ?1) -> ?2 x -> Sigma ?1 ?2
-- infer pair [Unit] [?2] tt => ?2 tt -> Sigma Unit ?2


-- infer pair [?1] [?2] tt tt => Unit * Unit


