
def id : [A : Type] -> A -> A {
  \x => x
}

data Equal : [A : Type] -> A -> A -> Type {
  refl : [A : Type] -> [x : A] -> Equal x x
}

def sym : [A : Type] -> [x : A] -> [y : A] -> Equal x y -> Equal y x {
  \e => case e {
    refl => refl
  }
}

data Nat : Type {
  z : Nat,
  s : Nat -> Nat
}

def plus : Nat -> Nat -> Nat {
  \x => case x {
    z => \y => y,
    s => \y => s (plus y)
  }
}



data Vect : (A : Type) -> Nat -> Type {
  nil : [A : Type] -> Vect A z,
  cons : [A : Type] -> [n : Nat] -> A -> Vect A n -> Vect A (s n)
}

