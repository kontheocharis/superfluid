
def id : [A : Type] -> A -> A {
  \x => x
}

data Equal : [A : Type] -> A -> A -> Type {
  refl : [A : Type] -> [x : A] -> Equal x x
}

def sym : [A : Type] -> [x : A] -> [y : A] -> Equal x y -> Equal y x {
  \e => case e {
    refl => refl
  }
}

data Nat : Type {
  z : Nat,
  s : Nat -> Nat
}

data Vect : (A : Type) -> Nat -> Type {
  nil : [A : Type] -> Vect A z,
  cons : [A : Type] -> [n : Nat] -> A -> Vect A n -> Vect A (s n)
}

def foo : _ {
  cons z (cons (s z) (cons (s (s z)) (nil [Nat])))
}

